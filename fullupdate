#!/bin/bash
# Inspired by: https://mutschler.eu/linux/install-guides/pop-os-post-install/#install-updates-and-reboot

set -eo pipefail

# Check for yq dependency
if ! command -v yq &> /dev/null; then
    echo "ERROR: yq is required but not installed. Install with:"
    echo "sudo snap install yq || sudo apt install yq"
    exit 1
fi

# Define section sequence
SECTION_SEQUENCE=("apt" "fwupdmgr" "flatpak" "snap" "vim_plugins" "git_repos")

# Parse command-line arguments
while getopts ":c:s:f:hv" opt; do
  case $opt in
    c) CONFIG_FILE="$OPTARG" ;;
    s) SECTIONS_OVERRIDE="$OPTARG" ;;
    f) START_FROM="$OPTARG" ;;
    h) 
      echo "Usage: $0 [-c CONFIG_FILE] [-s SECTIONS] [-f START_FROM] [-h] [-v]"
      echo "  -c    Path to custom config file (default: .fullupdate_config.yaml)"
      echo "  -s    Comma-separated sections to run (overrides config): apt,fwupdmgr,flatpak,snap,vim_plugins,git_repos"
      echo "  -f    Start from this component and run all subsequent components: apt,fwupdmgr,flatpak,snap,vim_plugins,git_repos"
      echo "  -h    Show this help message"
      echo "  -v    Show version"
      exit 0
      ;;
    v)
      echo "fullupdate v1.4"
      exit 0
      ;;
    \?) 
      echo -e "${RED}Invalid option: -$OPTARG${NC}" >&2
      exit 1
      ;;
  esac
done

# Handle environment variable for start from
if [[ -z "$START_FROM" && -n "$FULLUPDATE_FROM" ]]; then
    START_FROM="$FULLUPDATE_FROM"
fi

# Validate START_FROM if specified
if [[ -n "$START_FROM" ]]; then
    valid_section=false
    for section in "${SECTION_SEQUENCE[@]}"; do
        if [[ "$section" == "$START_FROM" ]]; then
            valid_section=true
            break
        fi
    done
    if [[ "$valid_section" == "false" ]]; then
        echo -e "${RED}ERROR: Invalid section for -f/--from: $START_FROM${NC}" >&2
        echo "Valid sections: ${SECTION_SEQUENCE[*]}"
        exit 1
    fi
fi

# Function to check if a section should run based on start position
should_run_based_on_position() {
    local section_name=$1
    
    # If no start position specified, run all sections
    if [[ -z "$START_FROM" ]]; then
        return 0
    fi
    
    # Find positions of the start section and current section
    local start_index=-1
    local current_index=-1
    
    for i in "${!SECTION_SEQUENCE[@]}"; do
        if [[ "${SECTION_SEQUENCE[$i]}" == "$START_FROM" ]]; then
            start_index=$i
        fi
        if [[ "${SECTION_SEQUENCE[$i]}" == "$section_name" ]]; then
            current_index=$i
        fi
    done
    
    # Run if current section is at or after start section
    [[ $current_index -ge $start_index ]]
}

# Resolve script location
SCRIPT_DIR=$(realpath "$(dirname "$0")")

# Set default config if not specified
if [[ -z "$CONFIG_FILE" ]]; then
    CONFIG_FILE="${SCRIPT_DIR}/.fullupdate_config.yaml"
fi

# Validate config file existence and accessibility
if [[ -n "$CONFIG_FILE" ]]; then
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo -e "${YELLOW}WARNING: Config file $CONFIG_FILE not found, using defaults${NC}"
        CONFIG_FILE=""
    elif [[ ! -r "$CONFIG_FILE" ]]; then
        echo -e "${RED}ERROR: Config file $CONFIG_FILE exists but is not readable${NC}"
        exit 1
    fi
fi

# Color output setup
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Function to check if a section should run
should_run_section() {
    local section_name=$1
    local config_path=$2

    # 1. Check environment variable first (FULLUPDATE_<SECTION>)
    local env_var="FULLUPDATE_${section_name^^}"
    if [[ -n "${!env_var}" ]]; then
        [[ "${!env_var}" == "1" || "${!env_var}" == "true" ]]
        return
    fi
    
    # 2. Check command-line override
    if [[ -n "$SECTIONS_OVERRIDE" ]]; then
        if [[ "$SECTIONS_OVERRIDE" == "all" ]]; then
            return 0
        elif [[ "$SECTIONS_OVERRIDE" == "none" ]]; then
            return 1
        else
            # Convert comma-separated list to array
            IFS=',' read -ra sections_array <<< "$SECTIONS_OVERRIDE"
            for s in "${sections_array[@]}"; do
                if [[ "$s" == "$section_name" ]]; then
                    return 0
                fi
            done
            return 1
        fi
    fi
    
    # 3. Check config file if exists
    if [[ -n "$CONFIG_FILE" && -f "$CONFIG_FILE" ]]; then
        enabled=$(yq eval "$config_path" "$CONFIG_FILE")
        [[ "$enabled" == "true" ]]
        return
    fi
    
    # 4. Default to enabled if no config or override
    return 0
}

# Function to check config enablement for sub-options
is_enabled() {
    local path=$1
    if [[ -z "$CONFIG_FILE" ]]; then
        return 0 # default to enabled if no config
    fi
    enabled=$(yq eval "$path" "$CONFIG_FILE")
    [[ "$enabled" == "true" ]]
}

# Timeshift snapshot (runs before section sequence)
if should_run_section "timeshift" '.timeshift.enable'; then
    echo -e "${GREEN}##### CREATING TIMESHIFT SNAPSHOT #####${NC}"
    sudo timeshift --create --comments "$(yq eval '.timeshift.comment' "$CONFIG_FILE")" \
        --tags "$(yq eval '.timeshift.tags | join(",")' "$CONFIG_FILE")"
    echo -e "##########################################\n\n"
fi

if should_run_section "apt" '.sections.apt.enable' && should_run_based_on_position "apt"; then
    echo -e "${GREEN}##### APT UPDATES #####${NC}"
    
    if is_enabled '.sections.apt.autoremove'; then
        echo -e "\n### apt autoremove ###"
        sudo apt autoremove -y
    fi
    
    if is_enabled '.sections.apt.autoclean'; then
        echo -e "\n### apt autoclean ###"
        sudo apt autoclean
    fi
    
    echo -e "\n### apt update ###"
    sudo apt update
    
    echo -e "\n### apt upgrade ###"
    sudo apt upgrade -y
    
    echo -e "\n### apt dist-upgrade ###"
    sudo apt dist-upgrade -y
    
    echo -e "${GREEN}##################################${NC}\n\n"
else
    echo -e "${YELLOW}##### SKIPPING APT UPDATES #####${NC}\n\n"
fi

if should_run_section "fwupdmgr" '.sections.fwupdmgr.enable' && should_run_based_on_position "fwupdmgr"; then
    echo -e "${GREEN}##### FIRMWARE UPDATES (fwupdmgr) #####${NC}"
    echo -e "\n### fwupdmgr get-devices ###"
    sudo fwupdmgr get-devices
    
    echo -e "\n### Checking for firmware updates ###"
    set +e
    sudo fwupdmgr get-updates
    fwupd_exit_code=$?
    set -e
    
    if [[ $fwupd_exit_code -eq 0 ]]; then
        echo -e "\n### Applying firmware updates ###"
        sudo fwupdmgr update
    else
        echo -e "${YELLOW}No firmware updates available${NC}"
    fi
    echo -e "${GREEN}#######################################${NC}\n\n"
else
    echo -e "${YELLOW}##### SKIPPING FIRMWARE UPDATES #####${NC}\n\n"
fi

if should_run_section "flatpak" '.sections.flatpak.enable' && should_run_based_on_position "flatpak"; then
    echo -e "${GREEN}##### FLATPAK UPDATES #####${NC}"
    echo -e "\n### Updating flatpak packages ###"
    flatpak update -y
    
    if is_enabled '.sections.flatpak.repair'; then
        echo -e "\n### Repairing flatpak installations ###"
        flatpak --user repair
    fi
    
    echo -e "${GREEN}###########################${NC}\n\n"
else
    echo -e "${YELLOW}##### SKIPPING FLATPAK UPDATES #####${NC}\n\n"
fi


if should_run_section "snap" '.sections.snap.enable' && should_run_based_on_position "snap"; then
    echo -e "${GREEN}##### SNAP UPDATES #####${NC}"
    echo -e "\n### Refreshing snap packages ###"
    sudo snap refresh
    echo -e "${GREEN}##########################${NC}\n\n"
else
    echo -e "${YELLOW}##### SKIPPING SNAP UPDATES #####${NC}\n\n"
fi

if should_run_section "vim_plugins" '.sections.vim_plugins.enable' && should_run_based_on_position "vim_plugins"; then
    echo -e "${GREEN}##### VIM PLUGIN UPDATES #####${NC}"
    echo -e "\n### Updating Vim plugins ###"
    cd ~ && vim +PluginUpdate +qall
    echo -e "${GREEN}#############################${NC}\n\n"
fi

# Git repo updates
if should_run_section "git_repos" '.sections.git_repos.enable' && should_run_based_on_position "git_repos"; then
    echo -e "${GREEN}##### GIT REPO UPDATES #####${NC}"
    
    # Get configured paths safely
    declare -a paths
    while IFS= read -r -d '' path; do
        paths+=("$(eval echo "$path")")  # Expand ~ to $HOME
    done < <(yq eval '.sections.git_repos.paths[]' "$CONFIG_FILE" | tr '\n' '\0')
    
    # Get excluded paths safely
    declare -A exclude
    while IFS= read -r -d '' path; do
        exclude["$(eval echo "$path")"]=1  # Expand ~ to $HOME
    done < <(yq eval '.sections.git_repos.exclude[]' "$CONFIG_FILE" | tr '\n' '\0')

    for path in "${paths[@]}"; do
        if [[ -d "$path" ]]; then
            echo -e "\n### Checking repos in ${path/#$HOME/~} ###"
            find "$path" -type d -name .git -print0 | while IFS= read -r -d $'\0' gitdir; do
                repo_dir=$(dirname "$gitdir")
                if [[ ! -v exclude["$repo_dir"] ]]; then
                    echo -e "\nUpdating ${repo_dir/#$HOME/~}"
                    git -C "$repo_dir" pull || echo -e "${RED}Failed to update ${repo_dir/#$HOME/~}${NC}"
                fi
            done
        fi
    done
    
    echo -e "${GREEN}###########################${NC}\n\n"
fi
